# JavaScript

<details>
    <summary>Что такое Javascript</summary>
      
  _**JavaScript**_ (JS) - это высокоуровневый( язык программировани),который применяется преимущественно для создания интерактивных веб-страниц.
  Он был создан в 1995 году и разработан компанией Netscape. JavaScript позволяет встраивать скрипты непосредственно в HTML-код веб-страницы,
  что позволяет изменять содержание страницы, обрабатывать события и взаимодействовать с пользователем без необходимости загрузки дополнительных ресурсов с сервера.
 
  Примеры функциональности JavaScript включают в себя изменение содержания HTML-элементов, обработку событий (например, кликов мыши или нажатий клавиш),
  валидацию форм, анимацию элементов, отправку запросов на сервер и динамическое обновление содержания страницы без необходимости её полной перезагрузки.

</details>

<details>
    <summary>Типы данных</summary>

    null - содержит одно значение (null)
    undefined - означает, что значение не было присвоено
    boolean.
    number.
    string.
    object - хранят коллекции данных
    Символ (symbol) - примитивный тип данных,использующийся для создания уникальных идентификаторов.
 *   let in = Symbol("id")

    BigInt - позволяет работать с числами большой длинны

</details>

<details>
    <summary>Типы Function и их отличия</summary>

  _**Function**_ - это блок кода который может быть использован множество раз.
  В JavaScript существует несколько типов функций, и их особенности могут варьироваться.
  Вот некоторые из основных типов функций:

 1 _**Объявление функции**_ (Function Declaration):
```js
 function myFunction() {
  // код функции
}
```
 - **Хостинг (Hoisting)**: Объявления функций поднимаются вверх в пределах своей области видимости, поэтому функцию можно вызвать до ее фактического объявления в коде.

 2  _**Выражение функции**_ (Function Expression):
```js
 let myFunction = function() {
  // код функции
};
```
 - **Хостинг**: Выражения функций не поднимаются вверх, как объявления функций. Вызывать функцию до ее объявления приведет к ошибке.

 3 _**Стрелочные функции (Arrow Functions):**_ 
```js
 const myFunction = () => {
  // код функции
};
```
 - **Контекст (this)**:Стрелочные функции не имеют собственного значения _**this**_ и заимствуют его из родительской области видимости.


 4 _**Конструктор функции**_ (Function Constructor):  
```js
 var myFunction = new Function('a', 'b', 'return a + b');
```
 - **Не рекомендуется**: Использование конструктора функций обычно не рекомендуется из-за потенциальных проблем с безопасностью и производительностью.

 5 _**Методы объекта:**_
 Функции, которые являются частью объекта, называются методами объекта.
```js
 var obj = {
  myMethod: function() {
    // код метода
  }
};
```
 - **Контекст (this)**: Контекст метода будет объект, к которому он принадлежит.



    

</details>

<details>
    <summary>Как this работает в JavaScript.</summary>

В JavaScript ключевое слово _**this**_ используется для ссылки на текущий объект, 
в контексте которого выполняется код. Значение this зависит от того, как вызывается функция.

#### Глобальный контекст:
* Если _**this**_ используется вне функции или объекта, оно ссылается 
на глобальный объект, который, в браузере, обычно является объектом window.
```js
console.log(this); // В глобальном контексте, например, в браузере, это будет объект window

```
#### Внутри функции:
* Значение _**this**_ внутри функции зависит от того, как функция была вызвана.

#### В строгом режиме( '_**use strict**_ ' ):
В строгом режиме this внутри функции, вызванной без контекста, будет **undefined**.
```js
'use strict';
function showThis() {
  console.log(this); // undefined
}
showThis();
```
#### Не в строгом режиме:
В нестрогом режиме _**this**_ внутри функции, вызванной без контекста, будет ссылаться на глобальный объект.
```js
function showThis() {
  console.log(this); // window (в браузере)
}
showThis();
```
#### Вызов функции как метода объекта:
Когда функция вызывается как метод объекта, _**this**_ ссылается на сам объект.
```js
const obj = {
  name: 'Example',
  showName: function() {
    console.log(this.name); // Example
  }
};
obj.showName();
```
#### Вызов функции с использованием call, apply или bind:
Методы _**call**_, _**apply**_ или _**bind**_ позволяют установить явный контекст вызова для функции.
```js
function sayHi() {
  console.log(`Hello, ${this.name}!`);
}

const person = { name: 'John' };

sayHi.call(person); // Hello, John!
sayHi.apply(person); // Hello, John!

const boundFunc = sayHi.bind(person);
boundFunc(); // Hello, John!
```
#### В стрелочных функциях:
Стрелочные функции не создают свой собственный контекст _**this**_ и заимствуют его у окружающего кода.
```js
const arrowFunction = () => {
  console.log(this); // Зависит от контекста, в котором была объявлена стрелочная функция
};
arrowFunction();
```
Использование _**this**_ может иногда быть запутанным, поэтому важно понимать, как оно ведет себя в различных сценариях вызова функций.
</details>

<details>
    <summary>Асинхронность в Javascript</summary>

Асинхронность в JavaScript - это концепция выполнения операций без блокировки основного потока выполнения программы. Вместо того чтобы ждать завершения операции, скрипт продолжает выполнение и внимание возвращается к операции позже, когда она завершится.

В JavaScript асинхронность обычно реализуется с использованием колбэков (callback functions), промисов (promises) и асинхронных функций (async/await). Вот несколько основных механизмов:

  _**Callback функции:**_ Функции, которые передаются в другие функции в качестве аргументов и вызываются после завершения определенной операции. Пример:
```js
 setTimeout(function() {
  console.log('Этот код выполнится спустя 2 секунды');
}, 2000);
```
_**Промисы (Promises):**_ Объекты, представляющие успешное или неудачное завершение асинхронной операции. Пример:
```js
 const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Операция выполнена успешно');
  }, 2000);
});

promise.then((result) => {
  console.log(result);
});
```
_**Async/await:**_ Синтаксический сахар для работы с промисами, делая код более читаемым. Пример:
```js
async function example() {
    try {
        const result = await someAsyncFunction();
        console.log(result);
    } catch (error) {
        console.error(error);
    }
}
```
Асинхронность позволяет эффективно обрабатывать операции ввода/вывода (например, запросы к серверу, чтение/запись файлов) и создавать более отзывчивые интерфейсы в веб-приложениях, избегая блокировки основного потока выполнения кода.

</details>

<details>
    <summary>Что такое Promise?</summary>

_**Promise**_ — специальный объект JavaScript, который используется для написания и
обработки асинхронного кода. Асинхронные функции возвращают объект Promise в качестве значения.
Внутри промиса работает асинхронная операция,
которая управляет его состоянием.

#### Промис может находиться в одном из трёх состояний:

- **pending** — промис ожидает, если результат не готов. То есть,
  ожидает завершение чего-либо(например, завершения асинхронной операции).
- **fulfilled** — получен результат;
- **rejected** — ошибка.

#### На promise можно навешивать колбэки двух типов:

* resolve – срабатывают, когда promise в состоянии «выполнен успешно».
* reject – срабатывают, когда promise в состоянии «выполнен с ошибкой».

#### Промис создаётся с помощью конструктора:
 ```js
 const promise = new Promise((resolve, reject) => ({...
}));
 ```

#### Методы объекта Promise
- **`Promise.all()`** - используют,
  когда нужно запустить несколько промисов параллельно и дождаться их выполнения.
  Возвращает массив значений всех переданных промисов, при этом сохраняя порядок оригинального (переданного) массива, но не порядок выполнения.
- **`Promise.allSettled()`** - Ожидает завершения всех полученных промисов (как исполнения так и отклонения).
  Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены),
  содержащий массив результатов исполнения полученных промисов.
- **`Promise.race()`** - используют, чтобы запустить несколько промисов и дождаться того,
  который выполнится быстрее.
  Принимает итерируемую коллекцию промисов (чаще всего — массив) и возвращает новый промис.
  Он завершится, когда завершится самый быстрый из всех переданных. Остальные промисы будут проигнорированы.
- **`Promise.reject(reason)`** - Возвращает промис, отклонённый из-за reason.
- **`Promise.resolve(value)`** - Возвращает промис, исполненный с результатом value.


<details>
    <summary>Пример кода .all()</summary>

```js
const promise1 = new Promise(resolve => setTimeout(() => resolve(1), 5000))
const promise2 = new Promise(resolve => setTimeout(() => resolve(2), 2000))
const promise3 = new Promise(resolve => setTimeout(() => resolve(3), 1000))

Promise.all([promise1, promise2, promise3])
  .then(([response1, response2, response3]) => {
    console.log(response1)
    // 1
    console.log(response2)
    // 2
    console.log(response3)
    // 3
  })
```
</details>


<details>
  <summary>Пример кода .race()</summary>

```js
const slow = new Promise(resolve => setTimeout(() => resolve(1), 6000))
const fast = new Promise(resolve => setTimeout(() => resolve(2), 3000))
const theFastest = new Promise(resolve => setTimeout(() => resolve(3), 1000))

Promise.race([slow, fast, theFastest])
        .then((value) => {
          console.log(value)
          // 3
        })
```
В консоль запишется результат выполнения theFastest, так как он выполнился быстрее всех.

</details>


</details>
 
<details>
    <summary>Event loop и его работа</summary>

В JavaScript, _**event loop**_ (цикл событий) - это механизм, который управляет порядком выполнения кода в асинхронной среде. Он позволяет обрабатывать события и выполнять асинхронный код без блокировки основного потока выполнения.

### Основные компоненты цикла событий в JavaScript:

#### Call Stack (Стек вызовов):
Это структура данных, которая отслеживает, в какой функции или части кода в данный момент находится выполнение.

#### Web APIs (веб-API): 
Браузер предоставляет веб-API, такие как _**setTimeout, fetch, XMLHttpRequest**_, которые позволяют выполнять асинхронный код.

#### Callback Queue (Очередь обратных вызовов):
Когда асинхронная операция завершается, её колбэк (функция обратного вызова) помещается в очередь обратных вызовов.

#### Event Loop (Цикл событий):
Он непрерывно проверяет стек вызовов и очередь обратных вызовов. Если стек вызовов пуст, и есть колбэк в очереди, он перемещает колбэк из очереди в стек вызовов для выполнения.

### Пример простого цикла событий в JavaScript:
```js
console.log('Start');

// Асинхронная операция с таймером
setTimeout(function() {
    console.log('Timeout callback');
}, 2000);

console.log('End');
```
В данном примере, порядок вывода будет "Start", затем "End", и, наконец, "Timeout callback". После установки таймера setTimeout, код продолжает выполнение без ожидания завершения таймера. Когда таймер завершается, его колбэк добавляется в очередь обратных вызовов, и цикл событий помещает его в стек вызовов для выполнения.

</details>

<details>
    <summary>Babel</summary>

_**Babel**_: это транспилер, который переписывает современный JavaScript-код в предыдущий стандарт.

_**Он состоит из двух частей**_:

1. Транспилер, который переписывает код. Разработчик запускает Babel на своём компьютере, и он переписывает код в старый стандарт. После этого код отправляется на сайт.

2. Полифил. Новые возможности языка могут включать встроенные функции и синтаксические конструкции. Транспилер переписывает код, преобразовывая новые синтаксические конструкции в старые.

</details>

<details>
    <summary>Полифил</summary>

_**Полифил**_ — это фрагмент кода (в сети — обычно JavaScript), который позволяет использовать современную функциональность(фичи) в более старых браузерах, которые не поддерживают ее по умолчанию.
Например, полифил можно использовать, чтобы эмулировать функциональность text-shadow в IE7 с помощью нативных фильтров браузера, или рем и медиавыражения, динамически меняя стилизацию в нужных случаях с помощью JavaScript, или что-либо еще, что вам потребуется.

</details>

<details>
    <summary>HTTP</summary>

_**HTTP (Hypertext Transfer Protocol)**_ определяет набор методов запросов, которые могут быть использованы для взаимодействия с ресурсами на веб-сервере. Вот четыре основных метода HTTP:

_**GET**_: Запрашивает представление ресурса. Запрос с использованием метода GET должен получить данные без внесения изменений в сервер или его состояние.

_**POST**_ : Используется для отправки данных на сервер для создания нового ресурса. Часто используется при отправке данных формы на веб-сайт.

_**PUT**_ : Запрос на изменение или создание ресурса на сервере. Клиент указывает новое представление ресурса, и сервер должен либо создать новый ресурс, либо заменить существующий.

_**DELETE**_ :
Запрос на удаление указанного ресурса на сервере.

_**Структура запроса**_

_**URL (Uniform Resource Locator)**_:Это адрес, по которому расположен ресурс на сервере. Например, https://api.example.com/users.

_**Заголовки (Headers)**_:Заголовки содержат метаданные запроса, такие как тип контента, формат данных, авторизационные данные и др.

_**Тело запроса (Request Body)**_:Присутствует в запросах типа POST, PUT, PATCH и содержит данные, которые вы хотите отправить на сервер. Обычно представлено в форматах JSON, XML или других, в зависимости от API.

Это основные методы HTTP, хотя существуют и другие, такие как PATCH, OPTIONS, HEAD и другие, каждый из которых предназначен для выполнения конкретных задач в рамках взаимодействия клиент-сервер.
</details>

<details>
    <summary>Prototype</summary>

Прототип (_**prototype**_) в JavaScript - это специальный объект, который используется для определения свойств и методов, которые будут унаследованы другими объектами. В простых словах, это как "заготовка" для создания новых объектов.

Когда вы создаете объект в JavaScript, у него есть прототип, который определяет его базовые свойства и методы. Если какое-то свойство или метод не найдено непосредственно в объекте, JavaScript ищет их в прототипе. Если они не найдены там, поиск продолжается в прототипе прототипа, и так далее, до тех пор, пока не будет найдено нужное свойство или метод, или не достигнут конечный прототип (обычно Object.prototype).

Прототипы позволяют создавать объекты на основе существующих, обеспечивая механизм наследования в JavaScript.

</details>









